import requests
import pandas as pd
import json
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
from forex_python.converter import CurrencyRates

'''Compile'''

df = pd.DataFrame()

TICKERS = ['ABB.ST', 'ALFA.ST', 'AMD', 'SAAB-B.ST', 'ERIC-B.ST',
          'FORTUM.HE', 'INVE-B.ST', 'NDA-SE.ST', 'NOKIA-SEK.ST',
          'SWED-A.ST', 'TEL2-B.ST', 'VOLV-B.ST']

for i in TICKERS:
    df = get_ticker(i, '2017-01-01', '2019-04-01', df, i)

df = remove_NaN(df)

df.columns = TICKERS

df = df.astype(float)

convert_EUR(df, 'FORTUM.HE')

convert_USD(df, 'AMD')

'''function arguments'''

returns = df.pct_change()
mean_returns = returns.mean()
cov_matrix = returns.cov()
num_portfolios = 10
risk_free_rate = 0.0178
cov_matrix.dtypes

display_simulated_ef_with_random(cov_matrix, mean_returns, num_portfolios, risk_free_rate)

'''End of Compilation'''

'''FUNCTIONS'''

def get_ticker(TICKER, DATE_FROM, DATE_TO, DATAFRAME, DF_TICKER):
    '''Gets historical DATA from a TICKER and given range, and then appends it to
    a DATAFRAME'''
    df = pd.DataFrame()
    API_KEY = 'mbad9NhOd3PkFvk4gzkmVeoimAlKhgsyJ0NhsvqrkvGePvod0u51ufUWjIEZ'
    url = 'https://www.worldtradingdata.com/api/v1/history?symbol=\
    {}&date_from={}&date_to{}&sort=newest&api_token={}'.format(TICKER, DATE_FROM, DATE_TO, API_KEY)
    
    '''Makes a request to the API that returns a JSON-response '''
    
    r = requests.get(url)
    sample = json.loads(r.text)
    
    '''Puts sample in Dataframe under each TICKER'''
    try:
        DF_TICKER = pd.DataFrame.from_dict(data=sample['history'],orient='index')
        cols = ['close']
        DF_TICKER = DF_TICKER[cols]
        DF_TICKER = DF_TICKER.rename(columns={'close':TICKER})
        if DATAFRAME.empty == True:
            DATAFRAME = DATAFRAME.append(DF_TICKER)
            print('First column')
            DATAFRAME.head()
            return DATAFRAME
        elif TICKER in DATAFRAME:
            print(TICKER, 'already in dataframe')
            return DATAFRAME

        else:
            DATAFRAME = pd.concat((DATAFRAME, DF_TICKER), axis=1, ignore_index=True, sort=True)
            print('Added:', TICKER)
            return DATAFRAME
    except:
        print('NO DATA IN RANGE', TICKER)
        return DATAFRAME

def remove_NaN(DATAFRAME):
    '''Removes ROWS with NaN-values '''
    DATAFRAME = DATAFRAME.dropna()
    return DATAFRAME

def convert_USD(DATAFRAME, TICKER):
    '''Converts prices from USD to SEK'''
    c = CurrencyRates()
    rate = c.get_rate('USD', 'SEK')
    DATAFRAME.loc[:,TICKER] *= rate
    return DATAFRAME
    
    
def portfolio_annualised_performance(weights, mean_returns, cov_matrix):
    returns = np.sum(mean_returns*weights ) *252
    std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)
    return std, returns
  
def random_portfolios(num_portfolios, mean_returns, cov_matrix, risk_free_rate):
    results = np.zeros((3,num_portfolios), object)
    print(type(results))
    weights_record = []
    for i in range(num_portfolios):
        weights = np.random.random(12)
        weights /= np.sum(weights)
        weights_record.append(weights)
        portfolio_std_dev, portfolio_return = portfolio_annualised_performance(weights, mean_returns, cov_matrix)
        results[0,i] = portfolio_std_dev
        results[1,i] = portfolio_return
        results[2,i] = (portfolio_return - risk_free_rate) / portfolio_std_dev
    print('FIRSTPRINT:',results[2])
    return results, weights_record
    
def display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate):
    results, weights = random_portfolios(num_portfolios, mean_returns, cov_matrix, risk_free_rate)
    
    
    max_sharpe_idx = np.argmax(results[2]).astype(float)
    sdp, rp = results[0,max_sharpe_idx], results[1,max_sharpe_idx]
    max_sharpe_allocation = pd.DataFrame(weights[max_sharpe_idx],index=table.columns,columns=['allocation'])
    max_sharpe_allocation.allocation = [round(i*100,2)for i in max_sharpe_allocation.allocation]
    max_sharpe_allocation = max_sharpe_allocation.T
    
    min_vol_idx = np.argmin(results[0])
    sdp_min, rp_min = results[0,min_vol_idx], results[1,min_vol_idx]
    min_vol_allocation = pd.DataFrame(weights[min_vol_idx],index=table.columns,columns=['allocation'])
    min_vol_allocation.allocation = [round(i*100,2)for i in min_vol_allocation.allocation]
    min_vol_allocation = min_vol_allocation.T
    
    print("-"*80)
    print("Maximum Sharpe Ratio Portfolio Allocation\n")
    print("Annualised Return:", round(rp,2))
    print("Annualised Volatility:", round(sdp,2))
    print("\n")
    print(max_sharpe_allocation)
    print("-"*80)
    print("Minimum Volatility Portfolio Allocation\n")
    print("Annualised Return:", round(rp_min,2))
    print("Annualised Volatility:", round(sdp_min,2))
    print("\n")
    print(min_vol_allocation)
    
    plt.figure(figsize=(10, 7))
    plt.scatter(results[0,:],results[1,:],c=results[2,:],cmap='YlGnBu', marker='o', s=10, alpha=0.3)
    plt.colorbar()
    plt.scatter(sdp,rp,marker='*',color='r',s=500, label='Maximum Sharpe ratio')
    plt.scatter(sdp_min,rp_min,marker='*',color='g',s=500, label='Minimum volatility')
    plt.title('Simulated Portfolio Optimization based on Efficient Frontier')
    plt.xlabel('annualised volatility')
    plt.ylabel('annualised returns')
    plt.legend(labelspacing=0.8)
    
